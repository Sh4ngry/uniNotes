\documentclass{article}
\usepackage{graphicx,subfig,hyperref} % Required for inserting images
\usepackage[margin=3cm]{geometry} %for the margin
\usepackage[most]{tcolorbox}
\title{Sistemi Operativi 1}
\author{Riccardo Cara}


\begin{document}
\maketitle
\tableofcontents
\newpage

\section{Introduzione}

    Un \textit{sistema operativo} è un software che si occupa di gestire le risorse hardware e fornire software di base che cambiano in base allo scopo del dispositivo.
    il sistema operativo si occupa di:

    \begin{itemize}
        \item \textbf{gestire le risorse hardware}
        gestire le risose fisiche condivise per raggiungere equità e efficenza
        \item \textbf{virtualizzare delle risorse}
        astrarre le risorse hardware per renderle disponibili al software sottoforma di risorsa virtuale.
        \item \textbf{interfacciare hardware e software}
        permette agli utenti di interagire con le risorse hardware senza controllarle direttamente.
    \end{itemize}
    %
    e viene diviso in due parti:

    \begin{itemize}
        \item \textbf{software di sistema}:
        tutti i software che non sono il kernel

        \item \textbf{kernel}:
        il nucleo dell'OS e si occupa di:
        
            \begin{itemize}
                \item \textbf{interfaccia hardware}
                interfacciare  i software con l'hardware

                \item \textbf{gestione della memoria}
                si occupa di distribuire la ram (Random Access Memory)
                
                \item \textbf{gestione dei processi}
                si occupa della gestione del tempo e quindi permette il multitasking
                
                \item \textbf{gestione dispositivi}
            \end{itemize}
            %
            un software effettua delle system calls ("syscall" per chi ha studiato assembly), il kernel traduce le chiamate in serie di comandi e le invia alla cpu.
        
        
    \end{itemize}

\section{Un sistema computerizzato}

    \begin{center}
    \includegraphics[width=0.8\textwidth]{immagini/immagine.png}
    \end{center}
    %
    questo è lo schema di un computer, si può osservare che esso è composto da più componenti connessi tra loro tramite un bus di sistema che permette ai componenti del computer di comunicare tra loro. I componenti sono:

    \begin{itemize}

        \item \textit{CPU}
         la parte che esegue le computazioni

        \item\textit{memoria principale}
        immagazzina dati e istruzioni usati dalla CPU, è condivisa tra CPU e dispositivi I/O

        \item\textit{dispositivi I/O}
        sono le periferiche, ovvero i dispositivi che permettono al computer di comunicare (monitor, stampante, mouse, tastiera,\ldots)

    \end{itemize}

    
    \subsection{Architettura di un computer}
        L'architettura di un computer è concettualmente identica tra Personal Computers, servers, smartphones ecc \ldots basato sul concetto di programma memorizzato, ovvero un computer che immagazzina i dati e le istruzioni dei programmi sullo stesso spazio di memoria. Prima di questa architettura, le istruzioni dei programmi e i dati erano salvati su spazi di memoria distinti, basti pensare a quando per cambiare programma si doveva cambiare scheda fisica. (non ne sono sicuro, forse era in un film, comunque il concetto è quello :D ).

        \begin{center}
        \includegraphics[width=0.8\textwidth]{immagini/architettura von neuman.png}
        \end{center}
        %
        In questo tipo di architettura, la CPU esegue le operazioni in maniera sequenziale usando registri interni mentre la memoria contiene le istruzioni e i dati.

        la CPU esegue tre passi in maniera ciclica:
        
        \begin{enumerate}
            \item \textbf{Fetch}:
            raccoglie l'istruzione dal Program Counter (un registro di memoria speciale della cpu in cui è contenuta l'istruzione da eseguire)

            \item \textbf{Decode}:
            interpreta l'istruzione fetchata

            \item \textbf{Execute}:
            esegue l'istruzione fetchata
        \end{enumerate}
        %
        la CPU può essere a processore singolo o a processori multipli, la differenza più grande è che la cpu a processori multipli incrementa il throughput, ovvero, nello stesso periodo di tempo, la cpu a processori multipli da in output una mole di dati maggiore rispetto al processore singolo. In questo corso ci concentreremo sui sistemi a processore singolo.

    \subsection{Memoria}
        La CPU possiede delle istruzioni, l'insieme di istruzioni viene definito dal linguaggio macchina. Le istruzioni in linguaggio macchina sono composte da un operatore (op code), zero o più operandi rappresentanti registri di memoria o indirizzi di memoria.
        
        In un Sistema computerizzato ci sono molte memorie, registri di memoria, cache, RAM, spazi di archiviazione(HDD, SSD) ecc\ldots queste memorie hanno un sistema gerarchico a livello di costi, capacità di memoria e a livello di tempo impiegato per accedervi:

        \begin{center}
            \includegraphics[width=1\textwidth]{immagini/gerarchia memorie.png}
        \end{center}
        %
        le memorie sono divise in due sottogruppi:
        %
        \begin{enumerate}
            \item \textbf{registri e cache}:
            sono gestiti dall'architettura

            \item \textbf{memoria principale, memoria non volatile, spazi di archiviazione}:
            sono gestiti dal sistema operativo
        \end{enumerate}

    \subsection{Bus di sistema}
        i bus di sistema sono 3:

        \begin{itemize}
            \item \textbf{Data Bus}:
            porta l'informazione

            \item \textbf{Address Bus}:
            determina dove l'informazione va inviata

            \item \textbf{Control Bus}:
            determina quale operazione viene effettuata
        \end{itemize}
%
        Se il control bus è condiviso tra memoria e dispositivi di I/O di cui si parlerà nella prossima sezione, si utilizzerà una linea speciale chiamata"\textbf{M/\#io}" ed indica se la CPU vuole comunicare con la memoria o con un dispositivo I/O.

    \subsection{dispositivi I/O}
        i dispositivi input output, sono divisi in 2 parti, il dispositivo in se e il device controller, ovvero un chip che permette di controllare una famiglia di device controller:

        \begin{itemize}
            \item \textbf{SATA controller}:
            controlla i dischi SATA
            
            \item \textbf{IDE controller}:
            controlla i dischi IDE
            
            \item \textbf{usb controller}:
            controlla i dispositivi USB
            
            \item \textbf{PCI bus controller:} controlla i dispositivi connessi al bus PCI
            \item \ldots
        \end{itemize}
        %
        il sistema computerizzato, comunica con gli elementi I/O tramite dei software chiamati driver: SATA driver, IDE driver, USB driver, PCI bus driver ecc\ldots

        \subsection{registri}
         I dispositivi I/O hanno dei registri dedicati con cui comunicare con il sistema computerizzato.

        \begin{itemize}
            \item \textbf{registri di stato}:
            registro in cui viene salvato lo stato del dispositivo(attende l'input, occupato, errore, transazione completata, idle, ecc\ldots)

            \item \textbf{registri di controllo/configurazione}:
            usato dalla CPU per configurare e controllare il dispositivo

            \item \textbf{registri dei dati}:
            usato per leggere o inviare dati dal/al dispositivo I/O
        \end{itemize}
        %
        La CPU può comuicare con i dispositivi I/O in due modi:
        
        \begin{itemize}
            \item \textbf{Port-mapped I/O}
            i riferimenti al controller avvengono tarmite uno spazio di indirizzi I/O separato.
            
            \begin{itemize}

                \item il registro di ogni device controller è mappato ad una porta (indirizzo) specifica durante il boot
                \item necessita di istruzioni della CPU speciali (IN per leggere dal dispositivo I/O, OUT per scriverci)
                \item non necessita di interpellare M/\#IO per le istruzioni IN, OUT poichè sono solo per i dispositivi I/O e non confondibili con altre istruzioni per la memoria.
                
            \end{itemize}
            
            \item \textbf{memory mapped I/O}
            i registri dei controller vengono mappati sugli stessi indirizzi usati per i registri di memoria.
            
            \begin{itemize}

                \item non necessita di istruzioni speciali
                \item le porte dei dispositivi I/O sono viste come normali indirizzi di memoria mappati nella RAM
                \item per accedere ai registri dei dispositivi I/O vengono usate istruzioni simili a MOV
                \item M/\#IO indica sempre che gli indirizzi richiesti dalla CPU appartengono alla memoria 
                
            \end{itemize}
        \end{itemize}

    \subsection{gestione I/O}
        Esistono due tipi di gestione dei dispositivi input e output. Uno è il \textit{polling} l'altro è l'\textit{interrupt driven}.
        Il polling è il controllo periodico della cpu sullo stato del dispositivo I/O.
        l'interrupt driven è un sistema di controllo in cui il dispositivo I/O invia un segnale di interrupt una volta che ha concluso un'azione.
        Le operazioni di gestione dei dispositivi I/O possono essere eseguiti dalla \textbf{CPU} che si occuperà di trasferire i dati oppure da un \textbf{DMAC} (Direct Memory Access Controller) solitamente accoppiato con il sistema di interrupt driven allo scopo di rimuovere la CPU dalla gestione dei dispositivi di I/O.

    \subsection{Servizi del Sistema Operativo}
        \subsubsection{Kernel/User Mode}
            la CPU ha dei comandi che non dovrebbero essere eseguiti da programmi, come esempio HLT per arrestare il sistema o INT X per inviare un interrupt.
            Per evitare che un qualsiasi programma possa usufruire di questi comandi, essi necessitano di essere eseguiti in \textbf{Kernel mode}, la CPU infatti può essere impostata in \textbf{User mode} o in kernel mode:

            \begin{itemize}
                \item \textbf{Kernel mode}
                La CPU in kernel mode non ha restrizioni e può quindi eseguire qualsiasi istruzione

                \item \textbf{User mode}
                la CPU in User mode ha delle restrizioni, quindi \textbf{non} può:

                    \begin{itemize}
                        \item accedere agli indirizzi riservati ai dispositivi I/O
                        \item passare a Kernel mode
                        \item modificare il contenuto della memoria principale
                        \item \ldots
                    \end{itemize}

            \end{itemize}
        %
        la modalità cambia in base ad un bit speciale contenuto in un registro protetto, quando il bit vale 0 si è in Kernel mode, quando il bit vale 1 si è in User mode, un esempio di questo cambio di modalità è quando avviene una \hyperref[sec:syscall]{system call}.
        
        Esistono anche altri tipi di protezione, in architetture moderne viene utilizzato un tipo di protezione ad anelli in cui c'è un nucleo che equivale alla Kernel mode e ad ogni anello aggiunto equivalgono più restrizioni.

        \begin{figure}[h]
            \centering
            \subfloat{\includegraphics[width=0.55\textwidth]{immagini/protection ring.png}}
            \hfill
            \subfloat{\includegraphics[width=0.4\textwidth]{immagini/memory protection.jpg}}
        \end{figure}
%
        Oltre alle restrizioni sulle istruzioni eseguite è importante imporre delle restrizioni anche sull'uso della memoria, un programma infatti non dovrebbe poter modificare i contenuti nello spazio di memoria riservato ad un altro programma, come non dovrebbe neanche poter modificare nulla dello spazio di memoria riservato all'OS.
        Un metodo per proteggere lo spazio di memoria dai programmi è assegnare due registri ad ogni programma nel momento del loro avvio, un \textbf{registro base} ed un \textbf{registro limite} e controllare che ogni accesso da parte di quel programma alla memoria avvenga nel range di registri tra il registro base e il registro limite.
    \subsubsection{system calls}
        \label{sec:syscall}
            \begin{tcolorbox}[colback= green!10!white, colframe= green!40!black, title=System Calls]

                una system call è una chiamata di sistema effettuata da un programma per richiedere uno dei servizi del sistema operativo, ad esempio stampa su schermo
            \end{tcolorbox}
            %
        esistono molte system calls, ma ricadono tutte in 6 categorie:
        \begin{itemize}
            \item \textbf{gestione dei file}
            ad esempio creazione ed eliminazione dei file, lettura e scrittura ecc\ldots

            \item \textbf{controllo dei processi}
            ad esempio l'esecuzione, la creazione e la terminazione di un processo, l'allocazione e la liberazione di memoria

            \item \textbf{controllo dei dispositivi}
            ad esempio leggere e scrivere su un dispositivo, connetterlo e disconnetterlo ecc\ldots

            \item \textbf{comunicazioni}
            ad esempio creazione ed eliminazione di connessioni, invio e ricezione di messaggi ecc\ldots
            
            \item \textbf{mantenimento delle informazioni}
            ad esempio il cambio dell'ora, della data, impostare le informazioni dei file ecc\ldots
        \end{itemize}
        %
        quando un programma effettua una syscall (System call), la richiede al sistema operativo tramite un \textbf{API} ovvero un interfaccia in grado di far comunicare il programma con il sistema operativo.
        Una volta che il programma ha richiesto la syscall, l'API la convertirà in un interrupt richiamando l'IVT (Interrupt Vector Table) tramite cui verrà avviato il System Call Handler che contiene una tabella con tutte le Syscall possibili e chiama la funzione che implemente la Syscall richiesta
\end{document}